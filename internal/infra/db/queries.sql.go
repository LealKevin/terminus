// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createPlayer = `-- name: CreatePlayer :one
INSERT INTO players (id, world_id, x, y, health, attack, defense, range)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, world_id, x, y, health, attack, defense, range, created_at, updated_at
`

type CreatePlayerParams struct {
	ID      pgtype.UUID
	WorldID pgtype.UUID
	X       int32
	Y       int32
	Health  int32
	Attack  int32
	Defense int32
	Range   int32
}

func (q *Queries) CreatePlayer(ctx context.Context, arg CreatePlayerParams) (Player, error) {
	row := q.db.QueryRow(ctx, createPlayer,
		arg.ID,
		arg.WorldID,
		arg.X,
		arg.Y,
		arg.Health,
		arg.Attack,
		arg.Defense,
		arg.Range,
	)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.WorldID,
		&i.X,
		&i.Y,
		&i.Health,
		&i.Attack,
		&i.Defense,
		&i.Range,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createWorld = `-- name: CreateWorld :one
INSERT INTO worlds (id, width, height, layout)
VALUES ($1, $2, $3, $4)
RETURNING id, width, height, layout, created_at, updated_at
`

type CreateWorldParams struct {
	ID     pgtype.UUID
	Width  int32
	Height int32
	Layout string
}

func (q *Queries) CreateWorld(ctx context.Context, arg CreateWorldParams) (World, error) {
	row := q.db.QueryRow(ctx, createWorld,
		arg.ID,
		arg.Width,
		arg.Height,
		arg.Layout,
	)
	var i World
	err := row.Scan(
		&i.ID,
		&i.Width,
		&i.Height,
		&i.Layout,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePlayer = `-- name: DeletePlayer :exec
DELETE FROM players
WHERE id = $1
`

func (q *Queries) DeletePlayer(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePlayer, id)
	return err
}

const deleteWorld = `-- name: DeleteWorld :exec
DELETE FROM worlds
WHERE id = $1
`

func (q *Queries) DeleteWorld(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteWorld, id)
	return err
}

const getPlayerByID = `-- name: GetPlayerByID :one
SELECT id, world_id, x, y, health, attack, defense, range, created_at, updated_at
FROM players
WHERE id = $1
`

func (q *Queries) GetPlayerByID(ctx context.Context, id pgtype.UUID) (Player, error) {
	row := q.db.QueryRow(ctx, getPlayerByID, id)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.WorldID,
		&i.X,
		&i.Y,
		&i.Health,
		&i.Attack,
		&i.Defense,
		&i.Range,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWorldByID = `-- name: GetWorldByID :one
SELECT id, width, height, layout, created_at, updated_at
FROM worlds
WHERE id = $1
`

func (q *Queries) GetWorldByID(ctx context.Context, id pgtype.UUID) (World, error) {
	row := q.db.QueryRow(ctx, getWorldByID, id)
	var i World
	err := row.Scan(
		&i.ID,
		&i.Width,
		&i.Height,
		&i.Layout,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listWorlds = `-- name: ListWorlds :many
SELECT id, width, height, layout, created_at, updated_at
FROM worlds
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListWorldsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListWorlds(ctx context.Context, arg ListWorldsParams) ([]World, error) {
	rows, err := q.db.Query(ctx, listWorlds, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []World
	for rows.Next() {
		var i World
		if err := rows.Scan(
			&i.ID,
			&i.Width,
			&i.Height,
			&i.Layout,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePlayer = `-- name: UpdatePlayer :one
UPDATE players
SET world_id = $8, x = $2, y = $3, health = $4, attack = $5, defense = $6, range = $7, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, world_id, x, y, health, attack, defense, range, created_at, updated_at
`

type UpdatePlayerParams struct {
	ID      pgtype.UUID
	X       int32
	Y       int32
	Health  int32
	Attack  int32
	Defense int32
	Range   int32
	WorldID pgtype.UUID
}

func (q *Queries) UpdatePlayer(ctx context.Context, arg UpdatePlayerParams) (Player, error) {
	row := q.db.QueryRow(ctx, updatePlayer,
		arg.ID,
		arg.X,
		arg.Y,
		arg.Health,
		arg.Attack,
		arg.Defense,
		arg.Range,
		arg.WorldID,
	)
	var i Player
	err := row.Scan(
		&i.ID,
		&i.WorldID,
		&i.X,
		&i.Y,
		&i.Health,
		&i.Attack,
		&i.Defense,
		&i.Range,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateWorld = `-- name: UpdateWorld :one
UPDATE worlds
SET width = $2, height = $3, layout = $4, updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, width, height, layout, created_at, updated_at
`

type UpdateWorldParams struct {
	ID     pgtype.UUID
	Width  int32
	Height int32
	Layout string
}

func (q *Queries) UpdateWorld(ctx context.Context, arg UpdateWorldParams) (World, error) {
	row := q.db.QueryRow(ctx, updateWorld,
		arg.ID,
		arg.Width,
		arg.Height,
		arg.Layout,
	)
	var i World
	err := row.Scan(
		&i.ID,
		&i.Width,
		&i.Height,
		&i.Layout,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
